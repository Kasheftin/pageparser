
PageParser 0.12

0.14 (2010.11.24)
	- изменение в методе match. Теперь $m[0] не возвращается в любом случае.

0.13 (2010.11.13)
	- добавлен новый метод select (select element).

0.12 (2010.11.03)
	- добавлен новый метод findAll.
	- добавлен новый метод replace.
	- добавлен новый метод select.

0.11 (2010.11.02)
	- добавлен новый метод rmempty.

0.1 (2010.11.01)
	- первая версия PageParser.




Класс для парсинга кода html-страницы.

Идея:
	пусть имеется html-код страницы, из которого нужно извлечь фиксированные данные. 
	Зачастую, обычный парсер - несколько хаотичная смесь регулярных сплитов и preg_match-ей (php). 
	Главная цель данного класса - стандартизация процесса парсинга страницы, единообразие команд.
	Вместе с тем, есть несколько оригинальных методов, упрощающих парсинг (например preg_match с учетом dom-структуры).

$pp = new PageParser();

Каждый метод возвращает ссылку на объект, поэтому возможен вызов по цепочке типа
$pp -> setOpt(..) -> set(..) -> split(..) -> findDom(..) -> save(..);

Устройство:
	Объект $pp содержит стек $htmls, каждый элемент стека - строка или массив из строк.
	Активным элементом стека всегда является последний добавленный элемент (он извлекается функцией array_pop).
	Большинство методов берут активный элемент стека, что-то с ним делают и перезаписывают его значение.

	$this->htmls - стек html-строк.
	$html = array_pop($this->htmls) - через $html обычно обозначается активный элемент стека.  

	set($html)
		- добавляет в стек $htmls новый элемент $html.
		- если $html - строка, в стек добавляется array(0=>$html).
		- если $html - массив, в стек добавляется массив из его значений (array_values). Ключи элементов массива намерено теряются.

	save(&$var)
		- записывает в переменную $var значение активного элемента стека ($html).
		- если $html - массив с одним элементом, возвращается значение элемента, в другом случае - весь $html.
	save(&$var,function)
		- перед записью к значению применяет func.

	begin(),b()
		- дублирует активный элемент стека (делает копию активного элемента и кладет ее в стек).
	
	rm(),end(),e()
		- удаляет из стека последний элемент.

	find(param1,param2)
		- выбирает строку, заключенную между param1 и param2 и перезаписывает получившимся значением активный элемент стека.
	find(param1,...,paramN)
		- выбирает все что после param1. Из получившегося - выбирает все что после param2, итд. до последнего элемента. 
		- последняя итерация - выбирает все что ДО paramN.
	find(param1,...,"*",...,paramN)
		- выбирает все что после param1, итд до элемента - '*', а после '*' выбирает все что до paramI+1,..,paramN.
	find(param1)
		- вызывает функцию preg_match(param1,$html,$m); Если $m - массив из двух элементов (т.е. в регулярном выражении - одни скобки), берет $m[1], в другом случае - весь массив $m.

	DOMfind(tag_start,tag_end,obstacle)
		- задача - выбрать все между tag_start и tag_end c учетом препятствия obstacle.
		- пример 
			- нужно выбрать блок в <div>-ах, при этом в этом блоке так же могут быть внутренние блоки из "<div>...</div>", и это нужно учесть.
			- рассмотрим
				<div class=a>
					...
					<div>...</div>
					<div>...</div>
				</div>
			- нужно выбрать содержание дива class='a'.
			- Пишем: ->DOMfind("/<div class=a>/","/<\/div>/","/<div>/")
			- это выражение выберет подстроку за tag_start, 
			- затем будет искать tag_end, но каждое встреченное до него препятствие obstacle увеличит внутренний счетчик. 
			- каждый встреченный tag_end уменьшает счетчик. 
			- процесс идет пока счетчик не обнулится.

	findAll(param1,...,paramN)
		- фактически обертка для preg_match_all. То же самое, что find, только ищет все вхождения, и все вхождения складывает в стек.

	split(p)
		- разбивает $html по выражению p на массив строк.
		- если активный элемент стека - уже массив из строк, разбивает каждый элемент массива на строки и складывает все получившиеся строки в один массив. 
		- в любом случае результат всегда одномерный массив из строк.
	split(p,limit,num)
		- разбивает $html по выражению p на массив строк с limit - количество кусков. num-ный кусок сохраняет в стек.
		- если $html - массив из нескольких элементов, разбивает по p каждый элемент с лимитом limit и выбирает num-ный кусок из каждого элемента.
	
	rm(n1,n2,...,ni)
		- удаляет n1,n2...ni - е элементы массива из $html, при этом меняется количество элементов в стеке-массиве.
	rmempty()
		- удаляет пустые элементы из $html.

	select($param1,$param2,...,$paramN)
		- к каждому элементу $str из $html применяет preg_match($paramI,$str). если хоть один из preg_match выдает false, удаляет этот элемент из $html.   

	replace($s1,$s2)
		- обертка для preg_replace($s1,$s2,$html), применяется ко всем элементам массива $html.



