
PageParser 0.2

0.2 (2011.01.02)
	- добавлен новый метод DOMFindAll
	- findAll теперь не возвращает $m[0] (Если $m[0] где-то нужен, всегда можно добавить скобки /(...)/)
	- добавлена новая конструкция each()
	- переименованы методы select, rm, rmempty, теперь так:
		rmById(n1,n2,..,ni) - удалить элементы n1,n2,..,ni из $html by id.
		selById(n1,n2,..,ni) - оставить только элементы n1,n2,..,ni, остальные удалить
		rm(regexp) - удалить элементы, которые подходят под regexp
		sel(regexp) - оставить только элементы, которые подходят под regexp

0.14 (2010.11.24)
	- изменение в методе match. Теперь $m[0] не возвращается в любом случае.

0.13 (2010.11.13)
	- добавлен новый метод select (select element).

0.12 (2010.11.03)
	- добавлен новый метод findAll.
	- добавлен новый метод replace.
	- добавлен новый метод select.

0.11 (2010.11.02)
	- добавлен новый метод rmempty.

0.1 (2010.11.01)
	- первая версия PageParser.




Класс для парсинга кода html-страницы.

Идея:
	пусть имеется html-код страницы, из которого нужно извлечь фиксированные данные. 
	Зачастую, обычный парсер - несколько хаотичная смесь регулярных сплитов и preg_match-ей (php). 
	Главная цель данного класса - стандартизация процесса парсинга страницы, единообразие команд.
	Вместе с тем, есть несколько оригинальных методов, упрощающих парсинг (например preg_match с учетом dom-структуры).

$pp = new PageParser();

Каждый метод возвращает ссылку на объект, поэтому возможен вызов по цепочке типа
$pp -> setOpt(..) -> set(..) -> split(..) -> findDom(..) -> save(..);

Устройство:
	Объект $pp содержит стек $htmls, каждый элемент стека - одномерный массив из строк.
	Активным элементом стека всегда является последний добавленный элемент (он извлекается функцией array_pop).
	Большинство методов берут активный элемент стека, что-то с ним делают и перезаписывают его значение.

	$this->htmls - стек html-строк.
	$html = array_pop($this->htmls) - через $html в методах обычно обозначается активный элемент стека.  

	set($html)
		- добавляет в стек $htmls новый элемент $html.
		- если $html - строка, в стек добавляется array(0=>$html).
		- если $html - массив, в стек добавляется массив из его значений (array_values). Ключи элементов массива намерено теряются.

	save(&$var)
		- записывает в переменную $var значение активного элемента стека ($html).
		- если $html - массив с одним элементом, возвращается значение элемента, в другом случае - весь $html.
	save(&$var,function)
		- перед записью к значению применяет func.

	begin(),b()
		- дублирует активный элемент стека (делает копию активного элемента и кладет ее в стек).
	
	end(),e()
		- удаляет из стека последний элемент.

	find(param1,param2)
		- выбирает строку, заключенную между param1 и param2 и перезаписывает получившимся значением активный элемент стека.
	find(param1,...,paramN)
		- выбирает все что после param1. Из получившегося - выбирает все что после param2, итд. до последнего элемента. 
		- последняя итерация - выбирает все что ДО paramN.
	find(param1,...,"*",...,paramN)
		- выбирает все что после param1, итд до элемента - '*', а после '*' выбирает все что до paramI+1,..,paramN.
	find(param1)
		- вызывает функцию preg_match(param1,$html,$m); Если $m - массив из двух элементов (т.е. в регулярном выражении - одни скобки), берет $m[1], в другом случае - весь массив $m без $m[0].

	DOMfind(tag_start,tag_end,obstacle)
		- задача - выбрать все между tag_start и tag_end c учетом препятствия obstacle.
		- пример 
			- нужно выбрать блок в <div>-ах, при этом в этом блоке так же могут быть внутренние блоки из "<div>...</div>", и это нужно учесть.
			- рассмотрим
				<div class=a>
					...
					<div>...</div>
					<div>...</div>
				</div>
			- нужно выбрать содержание дива class='a'.
			- Пишем: ->DOMfind("/<div class=a>/","/<\/div>/","/<div>/")
			- это выражение выберет подстроку за tag_start, 
			- затем будет искать tag_end, но каждое встреченное до него препятствие obstacle увеличит внутренний счетчик. 
			- каждый встреченный tag_end уменьшает счетчик. 
			- процесс идет пока счетчик не обнулится.

	findAll(param1,...,paramN)
		- фактически обертка для preg_match_all. То же самое, что find, только ищет все вхождения, и все вхождения складывает в стек.

	split(p)
		- разбивает $html по выражению p на массив строк.
		- если активный элемент стека - уже массив из строк, разбивает каждый элемент массива на строки и складывает все получившиеся строки в один массив. 
		- в любом случае результат всегда одномерный массив из строк.
	split(p,limit,num)
		- разбивает $html по выражению p на массив строк с limit - количество кусков. num-ный кусок сохраняет в стек.
		- если $html - массив из нескольких элементов, разбивает по p каждый элемент с лимитом limit и выбирает num-ный кусок из каждого элемента.

	rm(n1,n2,...,ni)
		- удаляет n1,n2...ni - е элементы массива из $html, при этом меняется количество элементов в стеке-массиве.
	rmempty()
		- удаляет пустые элементы из $html.

	select($param1,$param2,...,$paramN)
		- к каждому элементу $str из $html применяет preg_match($paramI,$str). если хоть один из preg_match выдает false, удаляет этот элемент из $html.   

	replace($s1,$s2)
		- обертка для preg_replace($s1,$s2,$html), применяется ко всем элементам массива $html.




	DOMSplit(p,obstacle), DOMSplit(p,obstacle,limit,num)
		- разбивает с учетом DOM-структуры.
		- пример: 
			<table>
				<tr><td>...</td></tr>
				<tr><td>...</td></tr>
			</table>
			нужно разбить по <tr>, но только одного верхнего уровня (внутри тоже могут быть таблицы с <tr>, по внутренним <tr> разбивать не нужно).
			...->DOMSplit("/<tr[^<>]*>/","/<\/tr[^<>]*>/") - делает то что нужно

	
	Большой пример:
	Есть данные в таблице:
		<table id="data">
			<tr>
				<td><table><tr><td><img src="/im/object1.gif"></td></tr></table></td>
				<td><a href="/?id=1">Object 1</a></td>
				<td>$100</td>
				<td>2011.01.01</td>
			</tr>
			<tr>
				<td><table><tr><td><img src="/im/object2.gif"></td></tr></table></td>
				<td><a href="/?id=2">Object 2</a></td>
				<td>$200</td>
				<td>2011.01.01</td>
	</tr>
			<tr>
				<td colspan=2><a href="/?id=3">Object 3</a></td>
				<td>$300</td>
				<td>2011.01.01</td>
			</tr>
		</table>
	Нужно написать парсер, который из данного кода получит массив:
	$data = array(
		0 => array("id"=>"1","name"=>"Object 1","price"=>"100","date"=>"2011.01.01","img"=>"/im/object1.gif"),
		1 => array("id"=>"2","name"=>"Object 2","price"=>"200","date"=>"2011.01.01","img"=>"/im/object2.gif"),
		2 => array("id"=>"3","name"=>"Object 3","price"=>"300","date"=>"2011.01.01","img"=>""),
	);

	Пусть html-код находится в переменной $str.

	Решение: 

	$pp = new PageParser();
	$pp	->set($str)
		->DOMFind("/<table[^<>]*id\s*=\s*[\"']?data[\"']?[^<>]*>/","/<\/table[^<>]*>/","/<table[^<>]*>/")
		->DOMFindAll("/<tr[^<>]*>/","/<\/tr[^<>]*>/","/<tr[^<>]*>/")
		->each()
			->DOMFindAll("/<td[^<>]*>/","/<\/td[^<>]*>/","/<td[^<>]*>/")
			->b()
				->select(0)
				->find("/<img[^<>]*src\s*=\s*[\"']?([^<>\"']*)[\"']?[^<>]*>/")
				->markAs("img")
			->e()
			->b()
				->select(1)
				->b()
					->find("/\/\?id=(\d+)/")
					->markAs("id")
				->e()
				->markAs("name",strip_tags)
			->e()
			->b()
				->select(2)
				->replace("/[^\d\.]/","")
				->markAs("price")
			->e()
			->b()
				->select(3)
				->markAs("date")
			->e()
		->endEach($data)
		->e();


